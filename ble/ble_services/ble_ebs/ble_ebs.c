/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.0.2116.0) */

#include "ble_ebs.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"
#include "ble_defined_uuids.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside ESCORT BASIS packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside ESCORT BASIS packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_VEHICHLE_IDENTIFY_NUMBER_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted vehichle identify number. */ 
#define MAX_USER_INFO_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted user info. */ 
#define MAX_WAREHOUSE_INFO_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted warehouse info. */ 
#define MAX_ESCORT_STATE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted escort state. */ 
#define MAX_CMD_UPDATE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted cmd update. */ 

/**@brief Function for encoding vehichle identify number.
 *
 * @param[in]   p_vehichle_identify_number              vehichle identify number characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t vehichle_identify_number_encode(ble_escort_basis_vehichle_identify_number_t * p_vehichle_identify_number, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint8_array_encode(&p_vehichle_identify_number->vin, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding vehichle identify number.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t vehichle_identify_number_decode(uint8_t data_len, uint8_t * p_data, ble_escort_basis_vehichle_identify_number_t * p_write_val)
{
    uint8_t pos = 0;
    pos += bds_uint8_array_decode((data_len-pos), &p_data[pos], &p_write_val->vin); 

    return pos;
}

/**@brief Function for encoding user info.
 *
 * @param[in]   p_user_info              user info characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t user_info_encode(ble_escort_basis_user_info_t * p_user_info, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint8_array_encode(&p_user_info->userid, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding user info.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t user_info_decode(uint8_t data_len, uint8_t * p_data, ble_escort_basis_user_info_t * p_write_val)
{
    uint8_t pos = 0;
    pos += bds_uint8_array_decode((data_len - pos), (p_data + pos), &p_write_val->userid); 

    return pos;
} 
/**@brief Function for encoding warehouse info.
 *
 * @param[in]   p_warehouse_info              warehouse info characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t warehouse_info_encode(ble_escort_basis_warehouse_info_t * p_warehouse_info, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint8_array_encode(&p_warehouse_info->warehouseinfo, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding warehouse info.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t warehouse_info_decode(uint8_t data_len, uint8_t * p_data, ble_escort_basis_warehouse_info_t * p_write_val)
{
    uint8_t pos = 0;
    pos += bds_uint8_array_decode((data_len-pos), &p_data[pos], &p_write_val->warehouseinfo); 

    return pos;
} 
/**@brief Function for encoding escort state.
 *
 * @param[in]   p_escort_state              escort state characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t escort_state_encode(ble_escort_basis_escort_state_t * p_escort_state, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_escort_state->escortstate;
    return len;
}

/**@brief Function for decoding escort state.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t escort_state_decode(uint8_t data_len, uint8_t * p_data, ble_escort_basis_escort_state_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->escortstate = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding cmd update.
 *
 * @param[in]   p_cmd_update              cmd update characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t cmd_update_encode(ble_escort_basis_cmd_update_t * p_cmd_update, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_cmd_update->cmd;
    return len;
}

/**@brief Function for decoding cmd update.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t cmd_update_decode(uint8_t data_len, uint8_t * p_data, ble_escort_basis_cmd_update_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->cmd = p_data[pos++]; 

    return pos;
} 

/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_escort_basis       ESCORT BASIS Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_escort_basis_t * p_escort_basis, ble_evt_t * p_ble_evt)
{
    p_escort_basis->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_escort_basis       ESCORT BASIS Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_escort_basis_t * p_escort_basis, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_escort_basis->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_escort_basis       ESCORT BASIS Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_escort_basis_t * p_escort_basis, ble_gatts_evt_write_t * p_ble_evt)
{
    
    if(p_ble_evt->handle == p_escort_basis->vehichle_identify_number_handles.value_handle)
    {
        if(p_escort_basis->evt_handler != NULL)
        {
            ble_escort_basis_evt_t evt;
            evt.evt_type = BLE_ESCORT_BASIS_VEHICHLE_IDENTIFY_NUMBER_EVT_WRITE;
            vehichle_identify_number_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.vehichle_identify_number);
            p_escort_basis->evt_handler(p_escort_basis, &evt);
        }
    }
    if(p_ble_evt->handle == p_escort_basis->user_info_handles.value_handle)
    {
        if(p_escort_basis->evt_handler != NULL)
        {
            ble_escort_basis_evt_t evt;
            evt.evt_type = BLE_ESCORT_BASIS_USER_INFO_EVT_WRITE;
            user_info_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.user_info);
            p_escort_basis->evt_handler(p_escort_basis, &evt);
        }
    }
    if(p_ble_evt->handle == p_escort_basis->warehouse_info_handles.value_handle)
    {
        if(p_escort_basis->evt_handler != NULL)
        {
            ble_escort_basis_evt_t evt;
            evt.evt_type = BLE_ESCORT_BASIS_WAREHOUSE_INFO_EVT_WRITE;
            warehouse_info_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.warehouse_info);
            p_escort_basis->evt_handler(p_escort_basis, &evt);
        }
    }
    if(p_ble_evt->handle == p_escort_basis->escort_state_handles.value_handle)
    {
        if(p_escort_basis->evt_handler != NULL)
        {
            ble_escort_basis_evt_t evt;
            evt.evt_type = BLE_ESCORT_BASIS_ESCORT_STATE_EVT_WRITE;
            escort_state_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.escort_state);
            p_escort_basis->evt_handler(p_escort_basis, &evt);
        }
    }
    if(p_ble_evt->handle == p_escort_basis->cmd_update_handles.value_handle)
    {
        if(p_escort_basis->evt_handler != NULL)
        {
            ble_escort_basis_evt_t evt;
            evt.evt_type = BLE_ESCORT_BASIS_CMD_UPDATE_EVT_WRITE;
            cmd_update_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cmd_update);
            p_escort_basis->evt_handler(p_escort_basis, &evt);
        }
    }
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_escort_basis_t * p_escort_basis, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_escort_basis       ESCORT BASIS Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_escort_basis_on_ble_evt(ble_escort_basis_t * p_escort_basis, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_escort_basis, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_escort_basis, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_escort_basis, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_escort_basis, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the ESCORT BASIS. */
uint32_t ble_escort_basis_init(ble_escort_basis_t * p_escort_basis, const ble_escort_basis_init_t * p_escort_basis_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_escort_basis->evt_handler = p_escort_basis_init->evt_handler;
    p_escort_basis->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    // Add a custom base UUID.
    ble_uuid128_t bds_base_uuid = BLE_EBS;
    uint8_t       uuid_type;
    err_code = sd_ble_uuid_vs_add(&bds_base_uuid, &uuid_type);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    ble_uuid.type = uuid_type;
    ble_uuid.uuid = BLE_EBS_BASE;
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_escort_basis->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add vehichle identify number characteristic
    ble_escort_basis_vehichle_identify_number_t vehichle_identify_number_initial_value = p_escort_basis_init->ble_escort_basis_vehichle_identify_number_initial_value; 

    uint8_t vehichle_identify_number_encoded_value[MAX_VEHICHLE_IDENTIFY_NUMBER_LEN];
    ble_add_char_params_t add_vehichle_identify_number_params;
    memset(&add_vehichle_identify_number_params, 0, sizeof(add_vehichle_identify_number_params));
    
    add_vehichle_identify_number_params.uuid                = BLE_EBS_VIDNUM;
    add_vehichle_identify_number_params.uuid_type           = ble_uuid.type; 
    add_vehichle_identify_number_params.max_len             = MAX_VEHICHLE_IDENTIFY_NUMBER_LEN;
    add_vehichle_identify_number_params.init_len            = vehichle_identify_number_encode(&vehichle_identify_number_initial_value, vehichle_identify_number_encoded_value);
    add_vehichle_identify_number_params.p_init_value        = vehichle_identify_number_encoded_value; 
    add_vehichle_identify_number_params.char_props.read     = 1; 
    add_vehichle_identify_number_params.read_access         = SEC_OPEN; 
    add_vehichle_identify_number_params.char_props.write_wo_resp    = 1; 
    add_vehichle_identify_number_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_vehichle_identify_number_params.is_var_len          = 1; 

    err_code = characteristic_add(p_escort_basis->service_handle, &add_vehichle_identify_number_params, &(p_escort_basis->vehichle_identify_number_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add user info characteristic
    ble_escort_basis_user_info_t user_info_initial_value = p_escort_basis_init->ble_escort_basis_user_info_initial_value; 

    uint8_t user_info_encoded_value[MAX_USER_INFO_LEN];
    ble_add_char_params_t add_user_info_params;
    memset(&add_user_info_params, 0, sizeof(add_user_info_params));
    
    add_user_info_params.uuid                = BLE_EBS_USERINFO;
    add_user_info_params.uuid_type           = ble_uuid.type; 
    add_user_info_params.max_len             = MAX_USER_INFO_LEN;
    add_user_info_params.init_len            = user_info_encode(&user_info_initial_value, user_info_encoded_value);
    add_user_info_params.p_init_value        = user_info_encoded_value; 
    add_user_info_params.char_props.read     = 1; 
    add_user_info_params.read_access         = SEC_OPEN; 
    add_user_info_params.char_props.write_wo_resp    = 1; 
    add_user_info_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_user_info_params.is_var_len          = 1; 

    err_code = characteristic_add(p_escort_basis->service_handle, &add_user_info_params, &(p_escort_basis->user_info_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add warehouse info characteristic
    ble_escort_basis_warehouse_info_t warehouse_info_initial_value = p_escort_basis_init->ble_escort_basis_warehouse_info_initial_value; 

    uint8_t warehouse_info_encoded_value[MAX_WAREHOUSE_INFO_LEN];
    ble_add_char_params_t add_warehouse_info_params;
    memset(&add_warehouse_info_params, 0, sizeof(add_warehouse_info_params));
    
    add_warehouse_info_params.uuid                = BLE_EBS_WHINFO;
    add_warehouse_info_params.uuid_type           = ble_uuid.type; 
    add_warehouse_info_params.max_len             = MAX_WAREHOUSE_INFO_LEN;
    add_warehouse_info_params.init_len            = warehouse_info_encode(&warehouse_info_initial_value, warehouse_info_encoded_value);
    add_warehouse_info_params.p_init_value        = warehouse_info_encoded_value; 
    add_warehouse_info_params.char_props.read     = 1; 
    add_warehouse_info_params.read_access         = SEC_OPEN; 
    add_warehouse_info_params.char_props.write_wo_resp    = 1; 
    add_warehouse_info_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_warehouse_info_params.is_var_len          = 1; 

    err_code = characteristic_add(p_escort_basis->service_handle, &add_warehouse_info_params, &(p_escort_basis->warehouse_info_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add escort state characteristic
    ble_escort_basis_escort_state_t escort_state_initial_value = p_escort_basis_init->ble_escort_basis_escort_state_initial_value; 

    uint8_t escort_state_encoded_value[MAX_ESCORT_STATE_LEN];
    ble_add_char_params_t add_escort_state_params;
    memset(&add_escort_state_params, 0, sizeof(add_escort_state_params));
    
    add_escort_state_params.uuid                = BLE_EBS_ESCORTSTATE;
    add_escort_state_params.uuid_type           = ble_uuid.type; 
    add_escort_state_params.max_len             = MAX_ESCORT_STATE_LEN;
    add_escort_state_params.init_len            = escort_state_encode(&escort_state_initial_value, escort_state_encoded_value);
    add_escort_state_params.p_init_value        = escort_state_encoded_value; 
    add_escort_state_params.char_props.read     = 1; 
    add_escort_state_params.read_access         = SEC_OPEN; 
    add_escort_state_params.char_props.write_wo_resp    = 1; 
    add_escort_state_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_escort_state_params.is_var_len          = 1; 

    err_code = characteristic_add(p_escort_basis->service_handle, &add_escort_state_params, &(p_escort_basis->escort_state_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add cmd update characteristic
    ble_escort_basis_cmd_update_t cmd_update_initial_value = p_escort_basis_init->ble_escort_basis_cmd_update_initial_value; 

    uint8_t cmd_update_encoded_value[MAX_CMD_UPDATE_LEN];
    ble_add_char_params_t add_cmd_update_params;
    memset(&add_cmd_update_params, 0, sizeof(add_cmd_update_params));
    
    add_cmd_update_params.uuid                = BLE_EBS_CMDUPDATE;
    add_cmd_update_params.uuid_type           = ble_uuid.type; 
    add_cmd_update_params.max_len             = MAX_CMD_UPDATE_LEN;
    add_cmd_update_params.init_len            = cmd_update_encode(&cmd_update_initial_value, cmd_update_encoded_value);
    add_cmd_update_params.p_init_value        = cmd_update_encoded_value; 
    add_cmd_update_params.char_props.read     = 1; 
    add_cmd_update_params.read_access         = SEC_OPEN; 
    add_cmd_update_params.char_props.write_wo_resp    = 1; 
    add_cmd_update_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_cmd_update_params.is_var_len          = 1; 

    err_code = characteristic_add(p_escort_basis->service_handle, &add_cmd_update_params, &(p_escort_basis->cmd_update_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for setting the vehichle identify number. */
uint32_t ble_escort_basis_vehichle_identify_number_set(ble_escort_basis_t * p_escort_basis, ble_escort_basis_vehichle_identify_number_t * p_vehichle_identify_number)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_VEHICHLE_IDENTIFY_NUMBER_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = vehichle_identify_number_encode(p_vehichle_identify_number, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_escort_basis->conn_handle, p_escort_basis->vehichle_identify_number_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the user info. */
uint32_t ble_escort_basis_user_info_set(ble_escort_basis_t * p_escort_basis, ble_escort_basis_user_info_t * p_user_info)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_USER_INFO_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = user_info_encode(p_user_info, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_escort_basis->conn_handle, p_escort_basis->user_info_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the warehouse info. */
uint32_t ble_escort_basis_warehouse_info_set(ble_escort_basis_t * p_escort_basis, ble_escort_basis_warehouse_info_t * p_warehouse_info)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_WAREHOUSE_INFO_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = warehouse_info_encode(p_warehouse_info, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_escort_basis->conn_handle, p_escort_basis->warehouse_info_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the escort state. */
uint32_t ble_escort_basis_escort_state_set(ble_escort_basis_t * p_escort_basis, ble_escort_basis_escort_state_t * p_escort_state)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_ESCORT_STATE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = escort_state_encode(p_escort_state, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_escort_basis->conn_handle, p_escort_basis->escort_state_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the cmd update. */
uint32_t ble_escort_basis_cmd_update_set(ble_escort_basis_t * p_escort_basis, ble_escort_basis_cmd_update_t * p_cmd_update)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_CMD_UPDATE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = cmd_update_encode(p_cmd_update, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_escort_basis->conn_handle, p_escort_basis->cmd_update_handles.value_handle, &gatts_value);
}

